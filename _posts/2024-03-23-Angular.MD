---
title: Angular
date: 2024-03-23 00:00:00 +0100
categories: [default]
tags: [angular, frontend] # TAG names should always be lowercase
---

## Table of Contents

-   [Table of Contents](#table-of-contents)
-   [Angular](#angular)
    -   [Installation, initialization](#installation-initialization)
    -   [Selectors](#selectors)
    -   [Directives](#directives)
-   [How it works](#how-it-works)
-   [Definitions](#definitions)
-   [Trivia](#trivia)
    -   [Trivia](#trivia-1)
    -   [Emmet](#emmet)
    -   [The rest](#the-rest)
-   [Testing](#testing)
    -   [`TestBed`](#testbed)
    -   [Testing HTTP Services](#testing-http-services)
    -   [Testing Components](#testing-components)
        -   [DOM Testing](#dom-testing)

## Angular

### Installation, initialization

1. To create Angular app, install Angular CLI and execute
    - `ng new my-app --no-strict --standalone false --routing false`
    - `--no-strict` at a beginning will help learning by not using strict mode
    - `--standalone false` as `standalone` is some other way of working with Angular
    - `--routing false` as for the beginning routing is not needed
2. In `angular.json` you can specify style sources
    - Ordering matters, so latter ones will override former ones
    - Set it in `projects.first-app.architect.build.options.styles` property
3. You can use Bootstrap for out-of-the-box useful styles
    - `npm install --save bootstrap@3`
    - Then reach your CSS located in `node_modules/bootstrap/dist/css/bootstrap.min.css`
4. `npm install` problems
    - When getting errors with `npm install`, a solution may be to run `npm install --legacy-peer-deps` instead of `npm install`.
5. Create Component from CLI
    - `ng generate component my-component`
    - or in short: `ng g c my-component`

### Selectors

1. Selector
    - It's the way Angular selects an element
2. Available Selectors
    - Element Selector
        - Used for Components
        - `my-component` -> `<my-component></my-component>`
    - Attribute Selector
        - `[my-component]` -> e.g. `<div my-component></div>`
    - Class Selector
        - `.my-component` -> e.g. `<div class="my-component"></div>`
    - ID Selectors, PseudoSelectors (like hover)
        - Not supported
3. Data Binding
    - It can be described as communication between Business Logic Layer (TypeScript) and Presentation Layer (HTML)
4. Data Binding possibilities
    - Output Data (from TS to HTML)
        - String Interpolation `{{ myValue }}`
        - Property Binding `[disabled]="userIsGuest"`
    - React to (User) Events
        - Event Binding `(event)="someExpression"`
    - Two-Way Data Binding
        - `[(ngModel)]="data"`
5. `<input type="text" [(ngModel)]="myVariable">`
    - Listen to everything that is inputted and save it in `myVariable`
    - At the same time listen to this variable and update `<input>` text accordingly
    - Notice that `ngModel` is imported from `FormsModule`
        - `import { FormsModule } from '@angular/forms';`
6. `$event`
    - Syntax for data emitted by a given event
    - Like keystroke in input
        - `<input type="text" (input)="onKeystroke($event)">`

### Directives

1. Directives
    - Instructions in the DOM
    - Structural Directives
        - It means it changes the structure of the DOM
        - It doesn't hide/unhide, it really adds/removes elements
        - Structural Directives start with a star `*` like e.g. `*ngIf`, `*ngFor`
    - Attribute Directives
        - They allow to manipulate attributes
        - Example: `ngStyle`
2. Create `*ngIf` with `else`
    - Create `*ngIf` element
        - `<p *ngIf="myPredicate"; else myReference>Predicate is satisfied</p>`
    - Create a local reference in an "else" element
        - `<ng-template #myReference><p>Predicate not satisfied</p></ng-template>`
3. `*ngFor`
    - Get index of current iteration
        - `*ngFor="let item of items; let i = index"`

## How it works

1. Angular actually replaces Component tags like `<app-root></app-root>` with HTML defined in corresponding `.html` files
2. Angular is for creating SPAs - Single Page Applications
    - Even if we have Routing, etc. it's still an SPA
    - It is because there's only one `index.html`
3. Angular CLI injects into `<script>` tag code that starts Angular
4. The first code that gets executed is `main.ts` file
5. By default, directories aren't scanned, so you have to specify Components in `app.module.ts` in `@NgModule` in `declarations` property
6. **TL;DR is that Angular changes DOM (HTML) at runtime**

## Definitions

1. Decorator
    - `@Something` <- this is Decorator
    - Java Annotations are TypeScript Decorators

## Trivia

### Trivia

1. Inline HTML/CSS for Component
    - You can inline define HTML template in `@Component` Decorator
        - instead of `templateUrl` property, use just `template`
        - instead of `stylesUrl`, use `styles`
2. `innerText` ~ `{{ }}`
    - Both these expressions are equivalent:
        - `<p [innerText]="myValue"></p>`
        - `<p>{{ myValue }}</p>`

### Emmet

1. Emmet
    - It's IDE plugin, which helps to work with HTML, CSS, JSX by expanding abbreviations
    - e.g. `app-component`, `Tab` becomes `<app-component></app-component>`
2. Create `div` with given `class`
    - creates `div` with given `class`
    - `.container` -> `<div class="container"></div>`

### The rest

## Testing

Running tests on WSL2 requires to handle Chrome executable.  
Therefore working with them is more straightforward on host system.

1. Run tests
    - Build app in watch mode, launch Karma test runner
    - `ng test`
2. Customize Karma test runner
    - Create `karma.conf.js`, update `angular.json`
    - `ng generate config karma`
3. Run tests in CI/CD
    - `ng test --no-watch --no-progress --browsers=ChromeHeadless`
4. Generate Coverage Report
    - `ng test --no-watch --code-coverage`
5. Some ways of injecting dependencies
    1. Just use real production service
        - `new SubjectUnderTest(new ProdService())`
    2. Use fake service
        - `new SubjectUnderTest(new FakeService())`
    3. Use fake object
        - `new SubjectUnderTest({ someFunction: () => 'fake value' } as ProdService)`
    4. Use Spy
        - ```js
          const serviceSpy = jasmine.createSpyObj("ProdService", [ 'someFunction' ]);
          const stubValue = "stub value";
          serviceSpy.someFunction.and.returnValue(stubValue);
          new SubjectUnderTest(serviceSpy);
          ```

### `TestBed`

1. `TestBed` creates a dynamically-constructed Angular test module that emulates an Angular `@NgModule`.
2. `TestBed.configureTestingModule()` method takes a metadata object that can have most of the properties of an `@NgModule`.
3. When you want to test a Service, use `providers` metadata property and specify there other Services you want to mock.
    - `TestBed.configureTestingModule({ providers: [ MyService, { provide: OtherService, useValue: spy } ] });`
    - Or if using real class, instead of `useValue`, use: `useClass: TestOtherService`
4. Inject it then using `const service = TestBed.inject(MyService)`
5. Example

    - ```js
      let myService: MyService;
      let otherServiceSpy: jasmine.SpyObj<OtherService>;

      beforeEach(() => (
        const spy = jasmine.createSpyObj('OtherService', ['someFunction']);
        TestBed.configureTestingModule({ providers: [ MyService, { provide: OtherService, useValue: spy } ]});
      ));

      myService = TestBed.inject(MyService);
      otherServiceSpy = TestBed.inject(OtherService) as jasmine SpyObj<OtherService>;
      ```

### Testing HTTP Services

1. ❗ Always provide both `next` and `error` callbacks for `Observable`s.  
   Otherwise you may encounter other tests failing in random places!
    - It is because without specifying `error`, you end up with an asynchronous uncaught observable error.
2. Example of HTTP test

    - ```js
      let httpClientSpy: jasmine.SpyObj<HttpClient>;
      let myService: MyService;

      beforeEach(() => {
        httpClientSpy = jasmine.createObjSpy('HttpClient', ['get']);
        myService = new MyService(httpClientSpy);
      });

      it('should return expected response', (done: DoneFn) => {
        const expectedValue = 'correct value';

        httpClientSpy.get.and.returnValue(asyncData(expectedValue));

        myService.someFunction().subscribe({
            next: (returnedValue) => {
                expect(returnedValue).toEqual(expectedValue);
                done();
            },
            error: done.fail,
        });
        expect(httpClientSpy.get.calls.count()).toBe(1);
      });
      ```

3. `HttpClientTestingModule`
    - Used for complex interactions
    - It's covered in [HttpGuide](https://angular.io/guide/http-test-requests)

### Testing Components

1. Remember to manually call [lifecycle hook methods](https://angular.io/guide/lifecycle-hooks) like `ngOnInit` (just as Angular would do)

#### DOM Testing

1. Component is more than just a class. It interacts with DOM and other Components.
    - Therefore tests covering only a class won't tell if Component renders, interacts with user or interact with other (e.g. parent or child) Components properly.
    - You need to examine DOM and simulate user interactions to be able to confirm Component works as intended.
2. When function call is asynchronous, you can use `waitForAsync()`
    - ```js
      beforeEach(waitForAsync(() => {
        TestBed.configureTestingModule({ imports: [ BannerComponent ]}).compileComponents();
      }));
      ```
3. Basic Component test assertion
    - Component can be created
    - `expect(component).toBeDefined();`
4. `createComponent()`
    - `TestBed.createComponent(MyComponent)` creates an instance of `MyComponent`, adds it to the DOM and returns a `ComponentFixture`
5. `ComponentFixture`
    - It's a harness for interacting with the created Component and its corresponding element
    - ```js
      const componentFixture = TestBed.createComponent(MyComponent);
      const component = componentFixture.componentInstance;
      expect(component).toBeDefined();
      ```
6. ❗ Don't reconfigure `TestBed` after calling `createComponent()`
    - `createComponent()` freezes the current `TestBed` definition, which makes it closed to further modifications
7. `NativeElement`
    - It's `any` type, as at a compile time it's unknown what type it is or even if it's an `HTMLElement`
        - Tests may be run on a non-browser platform such as WebWorker or any other that doesn't have DOM or where DOM-emulation doesn't support full `HTMLElement` API
    - In standard browser environment `nativeElement` will always be an `HTMLElement` (or one of it's derived classes)
    - You can use standard HTML API then, e.g. `querySelector()`
        - ```js
          const bannerElement: HTMLElement = componentFixture.nativeElement;
          const paragraph = bannerElement.querySelector('p')!;
          expect(p.textContext).toEqual('Hello World');
          ```
    - Under the hood it's actually `fixture.debugElement.nativeElement`
8. `DebugElement`
    - An abstraction to work safely across all platforms
    - Angular creates a `DebugElement` tree which wraps `NativeElement`s for the running platform
    - `DebugElement` contains methods and properties useful in testing
9. Example of testing
